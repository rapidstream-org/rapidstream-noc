"""Frontend to run the NoC pass."""

__copyright__ = """
Copyright (c) 2024 RapidStream Design Automation, Inc. and contributors.
All rights reserved. The contributor(s) of this file has/have agreed to the
RapidStream Contributor License Agreement.
"""

import json
import os
import subprocess
import sys
from enum import Enum, auto

from device import Device
from gen_vivado_bd import gen_arm_bd_hbm
from ir_helper import noc_rtl_wrapper, parse_floorplan, parse_inter_slot, parse_top_mod
from noc_pass import (
    get_slot_to_noc_nodes,
    greedy_selector,
    ilp_noc_selector,
    random_selector,
)
from tcl_helper import dump_streams_loc_tcl, export_constraint, gen_vivado_prj_tcl
from vh1582_nocgraph import vh1582_nocgraph
from vp1802_nocgraph import vp1802_nocgraph


class DeviceEnum(Enum):
    """Supported FPGA devices."""

    VH1582 = auto()
    VP1802 = auto()


class SelectorEnum(Enum):
    """Supported NoC selectors."""

    NONE = auto()
    EMPTY = auto()
    RANDOM = auto()
    GREEDY = auto()
    GRB = auto()


if __name__ == "__main__":
    # command line inputs
    NUM_CMD_IN = 5
    if len(sys.argv) < NUM_CMD_IN:
        print(
            f"""
Please provide:
    1. the JSON file generated by Rapidstream's NOC pass
    2. device name: {[e.name for e in DeviceEnum]}
    3. design's <mmap_port.json>
    4. selector: {[e.name for e in SelectorEnum]}
    5. <optional> absolute path of build directory.
       If not specified, will only run selector.
"""
        )
        sys.exit(1)

    # autobridge json file to extract
    rapidstream_json = sys.argv[1]
    device_name = sys.argv[2]
    mmap_port_json = sys.argv[3]
    selector = sys.argv[4]
    build_dir = sys.argv[5]

    # currently hard-coded parameters
    FREQUENCY = 250.0
    IMPL_FREQUENCY = "300.0"
    HBM_INIT_FILE = "/home/jakeke/rapidstream-noc/test/serpens_hbm24_nasa4704.mem"
    TB_FILE = "/home/jakeke/rapidstream-noc/test/serpens_tb_a48.sv"

    # intermediate dumps
    BD_NAME = "top_arm"
    GROUPED_MOD_NAME = "axis_noc_if"
    SELECTED_STREAMS_JSON = "noc_streams.json"
    NOC_PASS_JSON = "noc_pass.json"
    NOC_PASS_WRAPPER_JSON = "noc_pass_wrapper.json"
    RTL_FOLDER = "rtl/"
    NOC_CONSTRAINT_TCL = "noc_constraint.tcl"
    CONSTRAINT_TCL = "constraint.tcl"
    VIVADO_BD_TCL = "arm_bd.tcl"
    VIVADO_PRJ_TCL = "run.tcl"

    if device_name == DeviceEnum.VP1802.name:
        G = vp1802_nocgraph()
        PART_NUM = "xcvp1802-lsvc4072-2MP-e-S"
        BOARD_PART = "xilinx.com:vpk180:part0:1.2"
    elif device_name == DeviceEnum.VH1582.name:
        G = vh1582_nocgraph()
        PART_NUM = "xcvh1582-vsva3697-2MP-e-S"
        BOARD_PART = "xilinx.com:vhk158:part0:1.1"
    else:
        raise NotImplementedError

    with open(mmap_port_json, "r", encoding="utf-8") as file:
        mmap_port_ir = json.load(file)

    with open(rapidstream_json, "r", encoding="utf-8") as file:
        rapidstream_ir = json.load(file)

    top_mod_name = rapidstream_ir["modules"]["top_name"]
    print("Top module name:", top_mod_name)
    top_ir = parse_top_mod(rapidstream_ir)
    streams_slots, streams_widths = parse_inter_slot(top_ir)

    streams_bw = {}
    for s, w in streams_widths.items():
        streams_bw[s] = w * FREQUENCY / 8

    for a, b in streams_slots.items():
        print(a, b, streams_widths[a], streams_bw[a])
    assert len(streams_bw) == len(streams_slots), "parse_inter_slot ERROR"
    print("Number of inter-slot streams:", len(streams_slots))

    D = Device(
        part_num=PART_NUM,
        board_part=BOARD_PART,
        slot_width=2,
        slot_height=2,
        noc_graph=G,
        nmu_per_slot=[],  # generated
        nsu_per_slot=[],  # generated
        cr_mapping=[
            ["CLOCKREGION_X0Y0:CLOCKREGION_X4Y4", "CLOCKREGION_X0Y5:CLOCKREGION_X4Y7"],
            ["CLOCKREGION_X5Y0:CLOCKREGION_X9Y4", "CLOCKREGION_X5Y5:CLOCKREGION_X9Y7"],
        ],
    )

    if build_dir != "":
        if os.path.exists(build_dir):
            print(f"The folder '{build_dir}' already exists. Aborting.")
            sys.exit(1)
        else:
            zsh_cmds = f"""
mkdir {build_dir}
cp {rapidstream_json} {build_dir}/
"""
            print(zsh_cmds)
            subprocess.run(["zsh", "-c", zsh_cmds], check=True)

    # Main algorithm: select streams for NoC
    if selector in (SelectorEnum.NONE.name, SelectorEnum.EMPTY.name):
        noc_streams = []
    elif selector == SelectorEnum.RANDOM.name:
        noc_streams = random_selector(streams_slots, D)
    elif selector == SelectorEnum.GREEDY.name:
        noc_streams = greedy_selector(streams_slots, D)
    elif selector == SelectorEnum.GRB.name:
        noc_streams = ilp_noc_selector(streams_slots, streams_bw, D)
    else:
        raise NotImplementedError

    print("Selected streams for NoC", noc_streams)
    for s in noc_streams:
        print(f"{s}\t {streams_slots[s]}\t {streams_widths[s]}")

    if build_dir != "":
        # dumps the selected streams json
        noc_stream_json = {GROUPED_MOD_NAME: noc_streams}
        with open(
            f"{build_dir}/{SELECTED_STREAMS_JSON}", "w", encoding="utf-8"
        ) as file:
            json.dump(noc_stream_json, file, indent=4)

        # export noc constraints
        streams_nodes = get_slot_to_noc_nodes(streams_slots, D)
        tcl = dump_streams_loc_tcl(streams_nodes, noc_streams)
        with open(f"{build_dir}/{NOC_CONSTRAINT_TCL}", "w", encoding="utf-8") as file:
            file.write("\n".join(tcl))

        # generate grouped ir and rtl
        zsh_cmds = f"""
source ~/.zshrc && amd
rapidstream-optimizer -i {rapidstream_json} -o {build_dir}/{NOC_PASS_JSON} \
    create-group-wrapper --group-name-to-insts-json={build_dir}/{SELECTED_STREAMS_JSON}
"""
        print(zsh_cmds)
        subprocess.run(["zsh", "-c", zsh_cmds], check=True)

        # generate new rtl wrapper
        with open(f"{build_dir}/{NOC_PASS_JSON}", "r", encoding="utf-8") as file:
            noc_pass_ir = json.load(file)

        noc_pass_wrapper_ir = noc_rtl_wrapper(noc_pass_ir, GROUPED_MOD_NAME)

        with open(
            f"{build_dir}/{NOC_PASS_WRAPPER_JSON}", "w", encoding="utf-8"
        ) as file:
            json.dump(noc_pass_wrapper_ir, file, indent=4)

        zsh_cmds = f"""
rapidstream-exporter -i {build_dir}/{NOC_PASS_WRAPPER_JSON} -f {build_dir}/rtl
"""
        print(zsh_cmds)
        subprocess.run(["zsh", "-c", zsh_cmds], check=True)

        # generate vivado bd tcl
        bd_attr = {
            "bd_name": BD_NAME,
            "top_mod": top_mod_name,
            "hbm_init_file": HBM_INIT_FILE,
            "frequency": IMPL_FREQUENCY,
        }

        noc_stream_attr: dict[str, dict[str, str]] = {}
        for s in noc_streams:
            noc_stream_attr[f"m_axis_{s}"] = {}
            noc_stream_attr[f"m_axis_{s}"]["dest"] = f"s_axis_{s}"
            noc_stream_attr[f"m_axis_{s}"]["bandwidth"] = str(streams_bw[s])
            # round up to bytes
            noc_stream_attr[f"m_axis_{s}"]["width"] = str((streams_widths[s] + 7) // 8)

        tcl = gen_arm_bd_hbm(
            bd_attr=bd_attr,
            mmap_ports=mmap_port_ir,
            stream_attr=noc_stream_attr,
        )
        with open(f"{build_dir}/{VIVADO_BD_TCL}", "w", encoding="utf-8") as file:
            file.write("\n".join(tcl))

        # export constraints
        if selector == SelectorEnum.NONE.name:
            tcl = []
        else:
            with open(
                f"{build_dir}/{NOC_PASS_WRAPPER_JSON}", "r", encoding="utf-8"
            ) as file:
                noc_pass_wrapper_ir = json.load(file)

            floorplan = parse_floorplan(noc_pass_wrapper_ir, GROUPED_MOD_NAME)
            print("Number of modules:", sum(len(v) for v in floorplan.values()))
            print("Used slots: ", floorplan.keys())

            tcl = export_constraint(floorplan, D)

        with open(f"{build_dir}/{CONSTRAINT_TCL}", "w", encoding="utf-8") as file:
            file.write("\n".join(tcl))

        # generate vivado prj tcl
        tcl = gen_vivado_prj_tcl(
            {
                "build_dir": build_dir,
                "part_num": D.part_num,
                "board_part": D.board_part,
                "bd_name": BD_NAME,
                "rtl_dir": RTL_FOLDER,
                "tb_file": TB_FILE,
                "constraint": CONSTRAINT_TCL,
                "bd_tcl": VIVADO_BD_TCL,
                "noc_tcl": NOC_CONSTRAINT_TCL,
            }
        )
        with open(f"{build_dir}/{VIVADO_PRJ_TCL}", "w", encoding="utf-8") as file:
            file.write("\n".join(tcl))

        # launch vivado
        zsh_cmds = f"""
source ~/.zshrc && amd
cd {build_dir}
vivado -mode batch -source {VIVADO_PRJ_TCL}
"""
        print(zsh_cmds)
        subprocess.run(["zsh", "-c", zsh_cmds], check=True)
